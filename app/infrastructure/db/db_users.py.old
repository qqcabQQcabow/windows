from .pool import pool, CONSTRAINT_MESSAGES
import psycopg

from typing import Optional, Tuple, Any
from ..data_schemas import DriverRegistrInfo, LogistRegistrInfo, RoleEnum


def add_logist(data: LogistRegistrInfo, hash_p: str, salt_p: str) -> bool:
    """
    Return None if dont find hash
    Return (hash(str), salt(str))
    """

    user_data = {
        "login": data.login,
        "hash_password": hash_p,
        "hash_salt": salt_p,
        "phone": data.phone,
        "email": data.email,
        "name": data.name,
        "surname": data.surname,
        "patronymic": data.patronymic,
        "role": RoleEnum.LOGIST,
        "born_date": data.born_date,
    }

    logist_data = {
        "user_login": data.login,
    }

    with pool.connection() as con:
        try:
            with con.cursor() as cur:
                cur.execute(
                    """
                    insert into users (login, hash_password, hash_salt, phone, email, name, surname,
                                       patronymic, role, born_date, avatar)
                    values (%(login)s, %(hash_password)s, %(hash_salt)s, %(phone)s, %(email)s, 
                            %(name)s, %(surname)s, %(patronymic)s, %(role)s, to_timestamp(%(born_date)s), NULL) RETURNING login
                """,
                    user_data,
                )

                insert_1 = cur.fetchone()
                if insert_1 is None:
                    con.rollback()
                    return False

                cur.execute(
                    """
                insert into logists (user_login)
                values (%(user_login)s) RETURNING user_login
                """,
                    logist_data,
                )

                insert_2 = cur.fetchone()
                if insert_2 is None:
                    con.rollback()
                    return False

                con.commit()

                return True

        except psycopg.Error as e:
            con.rollback()
            constraint_name = getattr(e.diag, "constraint_name", None)
            if constraint_name and constraint_name in CONSTRAINT_MESSAGES:
                raise Exception(CONSTRAINT_MESSAGES[constraint_name])

            raise

        except Exception as e:
            con.rollback()
            raise e


def add_driver(data: DriverRegistrInfo, hash_p: str, salt_p: str):
    """
    Return None if dont find hash
    Return (hash(str), salt(str))
    """

    user_data = {
        "login": data.login,
        "hash_password": hash_p,
        "hash_salt": salt_p,
        "phone": data.phone,
        "email": data.email,
        "name": data.name,
        "surname": data.surname,
        "patronymic": data.patronymic,
        "role": RoleEnum.DRIVER,
        "born_date": data.born_date,
    }

    driver_data = {
        "user_login": data.login,
        "raiting": 0,
        "passport_numbers": data.passport_numbers,
        "driver_license_numbers": data.driver_license_numbers,
        "job_license_numbers": data.job_license_numbers,
        "snils_number": data.snils_numbers,
    }

    with pool.connection() as con:
        try:
            with con.cursor() as cur:
                cur.execute(
                    """
                    insert into users (login, hash_password, hash_salt, phone, email, name, surname,
                                       patronymic, role, born_date, avatar)
                    values (%(login)s, %(hash_password)s, %(hash_salt)s, %(phone)s, %(email)s, 
                            %(name)s, %(surname)s, %(patronymic)s, %(role)s, to_timestamp(%(born_date)s), NULL)
                """,
                    user_data,
                )

                cur.execute(
                    """
                    insert into drivers (user_login, raiting, passport_numbers, driver_license_numbers,
                                         job_license_numbers, snils_number)
                    values (%(user_login)s, %(raiting)s, %(passport_numbers)s, %(driver_license_numbers)s,
                            %(job_license_numbers)s, %(snils_number)s)
                """,
                    driver_data,
                )

                con.commit()

        except psycopg.Error as e:
            con.rollback()
            constraint_name = getattr(e.diag, "constraint_name", None)
            if constraint_name and constraint_name in CONSTRAINT_MESSAGES:
                raise Exception(CONSTRAINT_MESSAGES[constraint_name])

            raise

        except Exception as e:
            con.rollback()
            raise e


def get(login: str) -> Optional[dict]:
    """
    Return None if dont find hash
    Return user_json if success
    """

    with pool.connection() as con:
        with con.cursor() as cur:
            cur.execute(
                "select * from users where login = %(login)s ",
                {"login": login},
            )

            if cur.description:
                # получаем названия колонок
                colnames = cur.description
                # превращаем строки в словари
                data = cur.fetchone()
                if data is None:
                    return None

                rows = dict(zip(colnames, data))
                return rows

            return None


def get_role(login: str) -> Optional[str]:
    """
    Return None if dont find hash
    Return (hash(str), salt(str))
    """

    with pool.connection() as con:
        with con.cursor() as cur:
            cur.execute(
                "select role from users where login = %(login)s ",
                {"login": login},
            )

            res = cur.fetchone()
            if res is None:
                return None

            return res[0]


def get_password_hash_and_salt(login: str) -> Optional[Tuple[str, str]]:
    """
    Return None if dont find hash
    Return (hash(str), salt(str))
    """

    with pool.connection() as con:
        with con.cursor() as cur:
            cur.execute(
                "select hash_password, hash_salt from users where login = %(login)s ",
                {"login": login},
            )

            hash_p_and_s = cur.fetchone()
            if hash_p_and_s is None:
                return None

            return hash_p_and_s


def change_password_hash(login: str, new_hash: str, new_salt: str) -> bool:
    """
    Return true, if succes update
    Return False, if changed row count <= 0
    """

    with pool.connection() as con:
        try:
            with con.cursor() as cur:

                cur.execute(
                    "UPDATE users SET hash_password = %(new_hash)s, hash_salt = %(new_salt)s WHERE login = %(login)s",
                    {"login": login, "new_hash": new_hash, "new_salt": new_salt},
                )

                success = cur.rowcount > 0
                if success:
                    con.commit()
                    return True

                return False

        except Exception:
            con.rollback()
            return False


def driver_profile(login: str) -> dict[Any, Any]:
    with pool.connection() as con:
        try:
            with con.cursor() as cur:

                cur.execute(
                    """

                        SELECT
                            d.user_login,
                            d.raiting,
                            d.passport_numbers,
                            d.driver_license_numbers,
                            d.job_license_numbers,
                            d.snils_number,
                            u.phone,
                            u.email,
                            u.name,
                            u.surname,
                            u.patronymic,
                            u.role,
                            u.born_date
                        FROM drivers AS d
                        JOIN users  AS u ON u.login = d.user_login
                        where u.login = %(login)s
                        ORDER BY u.surname, u.name;

                        """,
                    {"login": login},
                )

                res = cur.fetchone()
                if res is None:
                    return {}

                if cur.description:
                    colnames = [desc[0] for desc in cur.description]
                    return dict(zip(colnames, res))

                return {}

        except Exception:
            return {}


def logist_profile(login: str) -> dict[Any, Any]:
    with pool.connection() as con:
        try:
            with con.cursor() as cur:

                cur.execute(
                    """

                        SELECT
                            u.phone,
                            u.email,
                            u.name,
                            u.surname,
                            u.patronymic,
                            u.role,
                            u.born_date
                        FROM logists AS l
                        JOIN users  AS u ON u.login = l.user_login
                        where u.login = %(login)s
                        ORDER BY u.surname, u.name;

                        """,
                    {"login": login},
                )

                res = cur.fetchone()
                if res is None:
                    return {}

                if cur.description:
                    colnames = [desc[0] for desc in cur.description]
                    return dict(zip(colnames, res))

                return {}

        except Exception:
            return {}
